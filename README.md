# Конвертер в текстовую графику

Вас пригласили поучаствовать в разработке приложения, умеющего скачивать картинки по URL и конвертировать изображения в текстовую графику (т. е. в текст из разных символов, которые в совокупности выглядят как изображение). Вот пример его работы. Картинка на нём — это текст из мелких символов:

![](pics/preview.png)

## Входные данные:
Часть приложения уже написана. Ваша задача — доработать его основную логическую часть в соответствии с требованиями. Поэтому для начала работы нужно скачать заготовку проекта. Для этого откройте идею, выберите в меню `File -> New -> Project from Version Control`. В открывшемся окне в поле URL введите `https://github.com/netology-code/java-diplom`, как показано на картинке, и нажмите Clone.

После откройте класс `Main` и запустите метод `main`. Запуск должен завершиться ошибкой:

```
Exception in thread "main" java.lang.IllegalArgumentException: Серверу нужно передать в конструктор объект-конвертер, а было передано null.
	at ru.netology.graphics.server.GServer.<init>(GServer.java:24)
	at ru.netology.graphics.Main.main(Main.java:13)
```

## Структура проекта
Перед вами java-проект с несколькими незнакомыми вам папками (например, `assets`), которые вам не нужно будет трогать. Нас будут интересовать .java-файлы, которые располагаются по пакетам:

![](pics/packages.png)

| Класс / Интерфейс      | Для чего? |
| ----------- | ----------- |
| `BadImageSizeException`      | Класс исключения, которое вы будете выбрасывать       |
| `TextColorSchema`   | Интерфейс цветовой схемы, который вы будете реализовывать        |
| `TextGraphicsConverter`   | Интерфейс конвертера картинок, который вы будете реализовывать        |
| `GServer`   | Готовый класс сервера, который будет использовать ваш конвертер; вам туда не нужно        |
| `Main`   | Запуск приложения. В нём запускается сервер, также в нём можно будет конвертировать картинки в текстовые файлы без сервера        |

## Требования к конвертеру
В проекте уже написан класс сервера, который будет использовать ваш конвертер. Т. к. конвертер ещё не написан, был создан специальный интерфейс `TextGraphicsConverter`, объект которого сервер ждёт параметром в `Main`:

```java
        TextGraphicsConverter converter = null; // Создайте тут объект вашего класса конвертера

        GServer server = new GServer(converter); // Создаём объект сервера
        server.start(); // Запускаем
```

Все требования к конвертеру [описаны](src/ru/netology/graphics/image/TextGraphicsConverter.java) в интерфейсе. Самый главный метод — это метод `convert`, который принимает параметром URL в виде текста, например, `«https://raw.githubusercontent.com/netology-code/java-diplom/main/pics/simple-test.png»`, внутри метода качает и анализирует картинку, после чего отдаёт значение типа `String`, в котором содержится это изображение в виде текстовой графики.

Помните, что в Java `String` — это текст и не обязательно всего одна строчка текста. Т. е. в один объект типа `String` можно занести многострочный текст,
а разделителем строк (по сути Enter) будет специальный символ, который пишется в коде как `\n`. В итоге у вас в конце каждой строчки текстового изображения будет символ переноса строки (запись в коде — `\n`).

## Выходные данные:
Пример работы конвертера, результат которого выводим в консоль:

```java
        String url = "https://raw.githubusercontent.com/netology-code/java-diplom/main/pics/simple-test.png";
        String imgTxt = converter.convert(url);
        System.out.println(imgTxt);
```

В итоге мы видим такой результат, где более тёмные участки заменяются на более жирные символы, а светлые на более незаметные символы:

![](pics/simple-test-demo.jpeg)

Также интерфейс конвертера требует от него возможность выставлять ему настройки перед конвертацией:

- максимально допустимое соотношение сторон (ширины и высоты). Если метод не вызывали, то любое соотношение допустимо;
- максимально допустимую высоту итогового изображения. Если метод не вызывали, то любая высота допустима;
- максимально допустимую ширину итогового изображения. Если метод не вызывали, то любая ширина допустима;
- текстовую цветовую схему — объект специального интерфейса, который будет отвечать за превращение степени белого (числа от 0 до 255) в символ. Если метод не вызывали, должен использоваться объект написанного вами класса как значение по умолчанию.

Например, следующий конвертер не должен конвертировать, если ширина больше длины в три раза, т. к. максимальное соотношение сторон ему выставлено в 2:

```java
        TextGraphicsConverter converter = ...; // Создайте тут объект вашего класса конвертера
	converter.setMaxRatio(2);  // выставляет максимально допустимое соотрношение сторон картинки
	String imgTxt = converter.convert(...); // для слишком широкой картинки должно выброситься исключение BadImageSizeException.
```

Будьте внимательны: когда вы передадите конвертер серверу, он выставит ему свои желаемые параметры, которые будут влиять на конвертацию:

![image](https://user-images.githubusercontent.com/53707586/178140398-a07f6c63-6049-465d-9330-fe01efb659b2.png)

При этом использовать при реализации конвертера информацию об этих конкретных числах нельзя. Ваш конвертер должен уметь работать с любыми настройками, описанными выше. Т. е. если в сервере поменяют настройки конвертеру, ваш конвертер без изменений кода должен работать с новыми значениями.

## Требования к цветовой схеме
Мы написали интерфейс конвертера так, чтобы сам он не подбирал каждому цвету определённый символ, но чтобы им занимался другой объект следующего интерфейса:

```java
public interface TextColorSchema {
    char convert(int color);
}
```

Предлагается следующая логика его работы. Вот список символов от самых тёмных к самым светлым: '▇', '●', '◉', '◍', '◎', '○', '☉', '◌', '-'. Если вы программируете на Windows, рекомендуем другой список из более стандартных символов, иначе может отрисовываться криво: '#', '$', '@', '%', '*', '+', '-', '\''. В зависимости от переданного значения интенсивности белого должен выбираться соответствующий символ. Например, если значение близко к 0, то выбрать надо '▇'; если к 255, то '-'. Если где-то посередине, то и выбирать надо тоже где-то посередине.

В итоге у вас должен быть класс, реализующий этот интерфейс. Если объекту конвертера сеттером не передали иную реализацию этого интерфейса, он должен использовать ваш класс как реализацию по умолчанию.

**Внимание:** Все ваши новые классы должны быть в пакете `ru.netology.graphics.image`, никакие другие классы, кроме класса `Main`, менять нельзя.

## Тестирование, отладка и решение проблем
После того как вы реализуете классы, откройте класс `Main` и заполните переменную для конвертера объектом вашего класса, чтобы он был передан серверу. Теперь после старта метода `main` будет запущен сервер на строке `server.start()`. Сервер будет писать о происходящем в консоль. Если ему удалось успешно стартовать, страница приложения будет доступна по локальному для вашего компьютера адресу http://localhost:8888/ .

Для конвертации достаточно вставить прямую ссылку на картинку в форму и нажать `Convert`. Если конвертация будет успешной, перед вами будет изображение, выполненное текстовой графикой. Его сервер получит от вашего конвертера. Если конвертер не сможет сконвертировать, то в консоли будет стек-трейс исключения, однако сервер при этом не упадёт, а продолжит работу. На веб-странице будет сообщение о том, что конвертация не удалась.

## Реализация:

1. Реализаовала класс цветовой схемы `ColorSchema`,имплементирующий интерфейс `TextColorSchema`. В нём создала метод конвертации цвета в символ, и цветовую симпольную схему по умолчани:

```java
package ru.netology.graphics.image;

public class ColorSchema implements TextColorSchema{
    private final char[] defSchema = {'#', '$', '@', '%', '*', '+', '-', '"'};
    private char[] schema;

    @Override
    public char convert(int color) {
        return this.schema[color / 32];
    }

    public void setSchema(char[] userSchema) {
        this.schema = userSchema;
    }

    public ColorSchema() {
        this.schema = defSchema;
    }
}
```
2. Создала класс `BadImageSizeException`, который будет выбрасывать исключение, если картинка не подходит под заданное соотношение сторон:
```java
package ru.netology.graphics.image;

public class BadImageSizeException extends Exception {
    public BadImageSizeException(double ratio, double maxRatio) {
        super("Максимальное соотношение сторон изображения " + maxRatio + ", а у этой " + ratio);
    }
}
```
3. Реализовала класс конвертера `GraphicsConverter`, имплементирующий интерфейс `TextGraphicsConverter`.
Конвертация изображения проходит в несколько этапов.
Во-первых, для картинки полученной по url высчитывается ее длина и ширина в пикселях, далее проверяется не превышается ли соотношение ее сторон. Если привышает, то выбрасывается исключение:

```java
BufferedImage img = ImageIO.read(new URL(url));

        int widthImage = img.getWidth(); // ширина исходной картинки
        int heightImage = img.getHeight(); // высота исходной картинки
        double ratioImage = widthImage > heightImage ? widthImage / heightImage : heightImage / widthImage;

        if (ratioImage > getMaxRatio()) {
            throw new BadImageSizeException(ratioImage, getMaxRatio());
        }
```
Далее, какая-то из сторон превышает заданные пользователем параметры, то изображение сжимается пропорционально со всех сторон под заданные пользователем размеры:

```java
int newWidth = 0;
        int newHeight = 0;

        boolean mark;
        if (widthImage >= heightImage) {
            mark = true;
        } else {
            mark = false;
        }

        // обе стороны больше заданных значений
        if (mark && (widthImage > getWidth()) && (heightImage > getHeight())) {
            int proportion = widthImage / getWidth();
            newWidth = widthImage / proportion;
            newHeight = heightImage / proportion;

            // хотя бы одна больше заданных параметров
        } else if (mark && (widthImage > getWidth() || heightImage > getHeight())) {
            int proportion = widthImage / getWidth();
            newWidth = widthImage / proportion;
            newHeight = heightImage / proportion;

        } else if (mark && (widthImage < getWidth() || heightImage < getHeight())) {
            newWidth = widthImage;
            newHeight = heightImage;

            //высота больше ширины
        } else {
            int proportion = heightImage / getHeight();
            newWidth = widthImage / proportion;
            newHeight = heightImage / proportion;
        }
```
После этого получила изображение, с которым буду дальше работать.
Создала объект для рисования, скопировала изображение и сделала его черно-белым. Оставила только интенсивность серого, она и нужна для дальнейшей конвертации в символы:

```java
 Image scaledImage = img.getScaledInstance(newWidth, newHeight, BufferedImage.SCALE_SMOOTH); //новая суженая картинка
        BufferedImage bwImg = new BufferedImage(newWidth, newHeight, BufferedImage.TYPE_BYTE_GRAY);
        Graphics2D graphics = bwImg.createGraphics();
        graphics.drawImage(scaledImage, 0, 0, null);
        WritableRaster bwRaster = bwImg.getRaster();
```
Следующим шагом создала пустой двумерный массив сопоставимый по длине и ширине картинке, в него, в цикле будут построчно вставляться сконвертированные символы:

```java
StringBuilder sb = new StringBuilder();
        char[][] arrayChar = new char[newHeight][newWidth];

        char c;
        String result = null;

        sb.append("<div style=\"white-space: nowrap;\">");
        for (int i = 0; i < arrayChar.length; i++) {
            for (int j = 0; j < arrayChar[i].length; j++) {
                int color = bwRaster.getPixel(j, i, new int[3])[0];
                c = schema.convert(color);

                sb
                        .append(c)
                        .append(c);
            }
            sb
                    .append("\n");
            result = sb.toString();
        }
        sb.append("</div>");
        return result;
```
На выходе получила одну большую строку, из последовательности символов, разделенных пробелами из заданной ранее схемы.
